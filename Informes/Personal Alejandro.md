# Informe Personal 
## Alejandro Escobar Giraudy C312

#### 1- Creación del bot
Se me asignó la tarea de buscar una solución computacional al problema en cuestión, no conocía como calcular el sentido del humor, si íbamos a hacer encuestas u otro tipo de mecanismo, pero si sabía que debíamos implementar un sistema computacional capaz de llegar a una población determinada... Un grupo de estudiantes de la facultad.
Pensando el problema un poco me di cuenta de que todos los estudiantes de la facultad tienen Telegram como una de la vías de comunicación más fiables tanto para propósitos personales como para la escuela manteniendo incluso grupos oficiales para cada asignatura, que además esta aplicación tiene una muy buena funcionalidad de poder implementar bots que tengan acceso a los grupos y puedan interactuar con los usuarios. Llegado a este punto parece evidente que un bot es una buena solución computacional para el problema en cuestión, que puede llegar fácilmente a todos los miembros del grupo deseado y con acceso todo el tiempo.
Por lo tanto luego de consultar con los integrantes del grupo y el profesor me dispuse a crear mi primer bot! Por lo tanto haciendo uso de la librería *python-telegram-bot* y *Bot Father*(bot con el que se crean todos los bots de Telegram) cree el primer bot que nos muestra la documentación de la librería para luego irle agregando nuestras funcionalidades, a su vez lo agregué al repositorio de *Github* creado por Airelys.

#### 2- Diseño e implementación de una encuesta
Después de haber jugado un poco con los comandos y botones de Telegram estaría listo para diseñar la encuesta que se necesita para aplicar el cuestionario que encontró Henri.
Para la misma era necesario crear un comando que lance una encuesta, la que estará compuesta por una pregunta y 4 botones con las 4 opciones de respuesta a la misma(completamente en desacuerdo, moderadamente en desacuerdo, moderadamente de acuerdo, completamente de acuerdo). 
Para ello primero agregamos el comando como un *ConversationHandler* asignándole el método que lanza la encuesta, dicho método que recibe como argumentos un *update* y un *context*, abre el *data.json* ya creado y que contiene las preguntas, accede a la pregunta deseada por su identificador y lanza un mensaje *update.message.reply_text* teniendo el argumento *text* igual a la pregunta seguida por *reply_markup* que guarda por argumento un *InlineKeyboard* con 4 botones creados con métodos que guardan en el json, dentro del grupo actual el integrante que responde la pregunta, el valor asignado a su correspondiente opción marcada, de haber marcado una opción antes se reemplaza dicho valor.
Así quedaría implementada una encuesta simple.

#### 3- Encuestas dinámicas y optimizaciones
Teniendo el diseño de encuestas ahora es necesario crearlas dinámicamente dado que son 60 preguntas, 240 botones a implementar con funciones similares. Para ello llevamos un contador por grupo que guarda la última encuesta que se ha puesto, y cuando llegue a 59 no se ponen más encuestas hasta que se ejecute el comando de reiniciar encuestas  que pone el mismo en 0.
Para crear dinámicamente la encuesta se accede al json de los datos, se toma como texto de la encuesta la pregunta correspondiente del json y se crea un lista de 4 botones, las 4 opciones, y como función que  ejecutan se crea dinámicamente 60*4 funciones de nombre *i_j* donde i es el número de la pregunta y j es la opción elegida, y se guarda entonces en los botones la que necesitemos. Estas funciones creadas dinámicamente son funciones creadas con la función *Add_Pull_Callback_Query_Handler* que al ejecutar el comando de mostrar encuestas este crea las funciones de tipo *CallbackQueryHandler* que implementa la función *Pulls_Buttons* la que tiene por argumentos *update* y *context*, del que extrae el nombre del usuario que responde la encuesta y por el data podemos tomar la variable que le pasamos al *callback data* en el que contempla el número de la opción seleccionada y el de la pregunta de la encuesta. De esta manera es posible crear las encuestas de forma dinámica, sin necesidad de tener implementado cada método de forma estática dado que es lo que normalmente se haría usando la librería *pyhton-telegram-bot*.
A esto hay que agregarle que es de tomar en cuenta que fue necesario ponerle una importante optimización al código dado que la librería mantiene de forma inmutable un límite temporal de respuestas y este al ser ejecutado varias veces consecutivas el botón inevitablemente estaría sobrepasando el límite.
De esta manera queda confeccionado al funcionalidad de lanzar encuestas desde 1, 3, 5 o 7 en una vez siendo estas accesibles hasta que se vuelva a lanzar el comando de mostrar encuestas o hasta que se termine la ejecución del bot.

#### 4- Detalles finales
Hablando con el profesor se fueron definiendo especificaciones adicionales que el gustaría implementado, ejemplo de estas son que se pueda "resetear" las preguntas una vez terminasen, este fue sencillo dado que solo bastaba poner una condicional para parar en caso de llegar a la última pregunta, y que se reinicie este contador con un comando, también que se enviaran los análisis al chat privado, este fue implementado con la ayuda de Airelys, otro es el que cuando se habilite el análisis el bot envíe un mensaje de feedback al usuario para que sepa que debe escribirle en el privado.

#### 5- Prueba y corrección de errores
El bot fue testeado en un grupo de los desarrolladores antes de probarlo en otros grupos, entre los tantos errores que encontramos se descubrió el límite temporal de respuesta, el cuál fuera de una optimización no se puede hacer mucho dado el carácter inmutable de los límites impuestos por *pyhton-telegram-bot*. Otro error encontrado fue el de los "super grupos" y grupos, hay una diferencia por la cantidad de integrantes, estos deben gestionarse aparte, para comprobar que al bot se le accede desde un grupo(o "super grupo") o desde el chat privado. Otros de los errores obtenidos tienen que ver en el análisis de los datos con los *nan*, o si los usuarios no respondían preguntas relacionadas a una característica, problemas resueltos entre Henri y yo. Otros son referentes a la codificación, dado que no se reconoce caracteres del español como ñ, ü, o tildes.

De esa manera concluye mi informe personal de mi trabajo en el bot.

